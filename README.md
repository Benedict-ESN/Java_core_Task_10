# JVM Comprehension


## Код для исследования

```java
public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```

## Анализ с точки зрения JVM

### Загрузка класса

#### 1. ClassLoader:
При запуске программы JVM использует систему загрузки классов (ClassLoaders) для загрузки класса JvmComprehension. 
Класс загружается в память - метаспейс.

### Выполнение кода

#### 2. Старт метода main:
``` public static void main(String[] args) ```

JVM создает фрейм в стэке для метода main.


#### 3. Строка 1:
``` int i = 1;                      // 1 ```

Примитивное значение 1 присваивается локальной переменной i в стэковом фрейме метода main.


#### 4. Строка 2:
``` Object o = new Object();        // 2 ```

Создается новый объект типа Object в куче (heap).
Ссылка на этот объект сохраняется в локальной переменной o в стэковом фрейме метода main.


#### 5. Строка 3:
``` Integer ii = 2;                 // 3 ```

Автобоксингом создается новый объект типа Integer со значением 2 в куче.
Ссылка на этот объект сохраняется в локальной переменной ii в стэковом фрейме метода main.


#### 6. Строка 4:
``` printAll(o, i, ii);             // 4 ```

- Вызывается метод printAll.
- Для метода printAll создается новый фрейм в стэке, и параметры метода (o, i, ii) передаются в него.
- Ссылки на объект Object и объект Integer из кучи передаются в параметры o и ii метода printAll.

### Метод printAll
``` private static void printAll(Object o, int i, Integer ii) ```

#### 7. Строка 5:
``` Integer uselessVar = 700;                   // 5 ```

- Автобоксингом создается новый объект типа Integer со значением 700 в куче.
- Ссылка на этот объект сохраняется в локальной переменной uselessVar в стэковом фрейме метода printAll.


#### 8. Строка 6:

``` System.out.println(o.toString() + i + ii);  // 6 ```

- Вызывается метод ``` o.toString() ```, который возвращает строковое представление объекта o. Эта строка создается в куче.
- Складываются строки и значения переменных i и ii. Для этого вызывается метод ``` ii.intValue() ```, который возвращает примитивное значение 2.
- В результате получается новая строка, которая создается в куче.
- Вызывается метод ``` System.out.println() ```, который создает новый фрейм в стэке для вывода строки на консоль.
- После завершения метода ``` System.out.println() ```, его фрейм удаляется из стэка.
- Возвращаемся из метода printAll в метод main:
- После выполнения метода printAll, его фрейм удаляется из стэка.

### Метод main

#### 9. Строка 7:
``` System.out.println("finished"); // 7 ```
- Создается строка "finished" в куче.
- Вызывается метод ``` System.out.println() ```, который создает новый фрейм в стэке для вывода строки на консоль.
- После завершения метода ``` System.out.println() ```, его фрейм удаляется из стэка.
- Завершение метода main:
- После завершения метода main, его фрейм удаляется из стэка.
- Все объекты, которые были созданы в куче и на которые больше нет ссылок, становятся кандидатами для сборки мусора (garbage collection).

#### 10. Сборщик мусора (Garbage Collection)
JVM может в любой момент запустить сборщик мусора для освобождения памяти, занятой объектами в куче, на которые больше нет ссылок. 
В нашем примере, это объекты Object, Integer и строковые объекты, которые были созданы во время выполнения и на которые больше нет ссылок после завершения метода main.


